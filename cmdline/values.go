// This file is autogenerated. Do not modify.

package cmdline

import (
	"fmt"
	"strconv"
	"time"

	"github.com/richardwilkes/gokit/errs"
)

// ----- bool -----
type boolValue bool

// NewBoolOption creates a new bool Option and attaches it to this CmdLine.
func (cl *CmdLine) NewBoolOption(val *bool) *Option {
	return cl.NewOption((*boolValue)(val))
}

// Set implements the Value interface.
func (val *boolValue) Set(str string) error {
	v, err := strconv.ParseBool(str)
	*val = boolValue(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *boolValue) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []bool -----
type boolArrayValue []bool

// NewBoolArrayOption creates a new []bool Option and attaches it to this CmdLine.
func (cl *CmdLine) NewBoolArrayOption(val *[]bool) *Option {
	return cl.NewOption((*boolArrayValue)(val))
}

// Set implements the Value interface.
func (val *boolArrayValue) Set(str string) error {
	v, err := strconv.ParseBool(str)
	*val = append(*val, v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *boolArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- int -----
type intValue int

// NewIntOption creates a new int Option and attaches it to this CmdLine.
func (cl *CmdLine) NewIntOption(val *int) *Option {
	return cl.NewOption((*intValue)(val))
}

// Set implements the Value interface.
func (val *intValue) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 64)
	*val = intValue(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *intValue) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []int -----
type intArrayValue []int

// NewIntArrayOption creates a new []int Option and attaches it to this CmdLine.
func (cl *CmdLine) NewIntArrayOption(val *[]int) *Option {
	return cl.NewOption((*intArrayValue)(val))
}

// Set implements the Value interface.
func (val *intArrayValue) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 64)
	*val = append(*val, int(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *intArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- int8 -----
type int8Value int8

// NewInt8Option creates a new int8 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt8Option(val *int8) *Option {
	return cl.NewOption((*int8Value)(val))
}

// Set implements the Value interface.
func (val *int8Value) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 8)
	*val = int8Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int8Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []int8 -----
type int8ArrayValue []int8

// NewInt8ArrayOption creates a new []int8 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt8ArrayOption(val *[]int8) *Option {
	return cl.NewOption((*int8ArrayValue)(val))
}

// Set implements the Value interface.
func (val *int8ArrayValue) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 8)
	*val = append(*val, int8(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int8ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- int16 -----
type int16Value int16

// NewInt16Option creates a new int16 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt16Option(val *int16) *Option {
	return cl.NewOption((*int16Value)(val))
}

// Set implements the Value interface.
func (val *int16Value) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 16)
	*val = int16Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int16Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []int16 -----
type int16ArrayValue []int16

// NewInt16ArrayOption creates a new []int16 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt16ArrayOption(val *[]int16) *Option {
	return cl.NewOption((*int16ArrayValue)(val))
}

// Set implements the Value interface.
func (val *int16ArrayValue) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 16)
	*val = append(*val, int16(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int16ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- int32 -----
type int32Value int32

// NewInt32Option creates a new int32 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt32Option(val *int32) *Option {
	return cl.NewOption((*int32Value)(val))
}

// Set implements the Value interface.
func (val *int32Value) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 32)
	*val = int32Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int32Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []int32 -----
type int32ArrayValue []int32

// NewInt32ArrayOption creates a new []int32 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt32ArrayOption(val *[]int32) *Option {
	return cl.NewOption((*int32ArrayValue)(val))
}

// Set implements the Value interface.
func (val *int32ArrayValue) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 32)
	*val = append(*val, int32(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int32ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- int64 -----
type int64Value int64

// NewInt64Option creates a new int64 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt64Option(val *int64) *Option {
	return cl.NewOption((*int64Value)(val))
}

// Set implements the Value interface.
func (val *int64Value) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 64)
	*val = int64Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int64Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []int64 -----
type int64ArrayValue []int64

// NewInt64ArrayOption creates a new []int64 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewInt64ArrayOption(val *[]int64) *Option {
	return cl.NewOption((*int64ArrayValue)(val))
}

// Set implements the Value interface.
func (val *int64ArrayValue) Set(str string) error {
	v, err := strconv.ParseInt(str, 0, 64)
	*val = append(*val, v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *int64ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- uint -----
type uintValue uint

// NewUintOption creates a new uint Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUintOption(val *uint) *Option {
	return cl.NewOption((*uintValue)(val))
}

// Set implements the Value interface.
func (val *uintValue) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 64)
	*val = uintValue(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uintValue) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []uint -----
type uintArrayValue []uint

// NewUintArrayOption creates a new []uint Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUintArrayOption(val *[]uint) *Option {
	return cl.NewOption((*uintArrayValue)(val))
}

// Set implements the Value interface.
func (val *uintArrayValue) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 64)
	*val = append(*val, uint(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uintArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- uint8 -----
type uint8Value uint8

// NewUint8Option creates a new uint8 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint8Option(val *uint8) *Option {
	return cl.NewOption((*uint8Value)(val))
}

// Set implements the Value interface.
func (val *uint8Value) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 8)
	*val = uint8Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint8Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []uint8 -----
type uint8ArrayValue []uint8

// NewUint8ArrayOption creates a new []uint8 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint8ArrayOption(val *[]uint8) *Option {
	return cl.NewOption((*uint8ArrayValue)(val))
}

// Set implements the Value interface.
func (val *uint8ArrayValue) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 8)
	*val = append(*val, uint8(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint8ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- uint16 -----
type uint16Value uint16

// NewUint16Option creates a new uint16 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint16Option(val *uint16) *Option {
	return cl.NewOption((*uint16Value)(val))
}

// Set implements the Value interface.
func (val *uint16Value) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 16)
	*val = uint16Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint16Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []uint16 -----
type uint16ArrayValue []uint16

// NewUint16ArrayOption creates a new []uint16 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint16ArrayOption(val *[]uint16) *Option {
	return cl.NewOption((*uint16ArrayValue)(val))
}

// Set implements the Value interface.
func (val *uint16ArrayValue) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 16)
	*val = append(*val, uint16(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint16ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- uint32 -----
type uint32Value uint32

// NewUint32Option creates a new uint32 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint32Option(val *uint32) *Option {
	return cl.NewOption((*uint32Value)(val))
}

// Set implements the Value interface.
func (val *uint32Value) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 32)
	*val = uint32Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint32Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []uint32 -----
type uint32ArrayValue []uint32

// NewUint32ArrayOption creates a new []uint32 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint32ArrayOption(val *[]uint32) *Option {
	return cl.NewOption((*uint32ArrayValue)(val))
}

// Set implements the Value interface.
func (val *uint32ArrayValue) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 32)
	*val = append(*val, uint32(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint32ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- uint64 -----
type uint64Value uint64

// NewUint64Option creates a new uint64 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint64Option(val *uint64) *Option {
	return cl.NewOption((*uint64Value)(val))
}

// Set implements the Value interface.
func (val *uint64Value) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 64)
	*val = uint64Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint64Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []uint64 -----
type uint64ArrayValue []uint64

// NewUint64ArrayOption creates a new []uint64 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewUint64ArrayOption(val *[]uint64) *Option {
	return cl.NewOption((*uint64ArrayValue)(val))
}

// Set implements the Value interface.
func (val *uint64ArrayValue) Set(str string) error {
	v, err := strconv.ParseUint(str, 0, 64)
	*val = append(*val, v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *uint64ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- float32 -----
type float32Value float32

// NewFloat32Option creates a new float32 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewFloat32Option(val *float32) *Option {
	return cl.NewOption((*float32Value)(val))
}

// Set implements the Value interface.
func (val *float32Value) Set(str string) error {
	v, err := strconv.ParseFloat(str, 32)
	*val = float32Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *float32Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []float32 -----
type float32ArrayValue []float32

// NewFloat32ArrayOption creates a new []float32 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewFloat32ArrayOption(val *[]float32) *Option {
	return cl.NewOption((*float32ArrayValue)(val))
}

// Set implements the Value interface.
func (val *float32ArrayValue) Set(str string) error {
	v, err := strconv.ParseFloat(str, 32)
	*val = append(*val, float32(v))
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *float32ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- float64 -----
type float64Value float64

// NewFloat64Option creates a new float64 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewFloat64Option(val *float64) *Option {
	return cl.NewOption((*float64Value)(val))
}

// Set implements the Value interface.
func (val *float64Value) Set(str string) error {
	v, err := strconv.ParseFloat(str, 64)
	*val = float64Value(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *float64Value) String() string {
	return fmt.Sprintf("%v", *val)
}

// ----- []float64 -----
type float64ArrayValue []float64

// NewFloat64ArrayOption creates a new []float64 Option and attaches it to this CmdLine.
func (cl *CmdLine) NewFloat64ArrayOption(val *[]float64) *Option {
	return cl.NewOption((*float64ArrayValue)(val))
}

// Set implements the Value interface.
func (val *float64ArrayValue) Set(str string) error {
	v, err := strconv.ParseFloat(str, 64)
	*val = append(*val, v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *float64ArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += fmt.Sprintf("%v", v)
	}
	return str
}

// ----- string -----
type stringValue string

// NewStringOption creates a new string Option and attaches it to this CmdLine.
func (cl *CmdLine) NewStringOption(val *string) *Option {
	return cl.NewOption((*stringValue)(val))
}

// Set implements the Value interface.
func (val *stringValue) Set(str string) error {
	v, err := str, error(nil)
	*val = stringValue(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *stringValue) String() string {
	return string(*val)
}

// ----- []string -----
type stringArrayValue []string

// NewStringArrayOption creates a new []string Option and attaches it to this CmdLine.
func (cl *CmdLine) NewStringArrayOption(val *[]string) *Option {
	return cl.NewOption((*stringArrayValue)(val))
}

// Set implements the Value interface.
func (val *stringArrayValue) Set(str string) error {
	v, err := str, error(nil)
	*val = append(*val, v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *stringArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += v
	}
	return str
}

// ----- time.Duration -----
type durationValue time.Duration

// NewDurationOption creates a new time.Duration Option and attaches it to this CmdLine.
func (cl *CmdLine) NewDurationOption(val *time.Duration) *Option {
	return cl.NewOption((*durationValue)(val))
}

// Set implements the Value interface.
func (val *durationValue) Set(str string) error {
	v, err := time.ParseDuration(str)
	*val = durationValue(v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *durationValue) String() string {
	return time.Duration(*val).String()
}

// ----- []time.Duration -----
type durationArrayValue []time.Duration

// NewDurationArrayOption creates a new []time.Duration Option and attaches it to this CmdLine.
func (cl *CmdLine) NewDurationArrayOption(val *[]time.Duration) *Option {
	return cl.NewOption((*durationArrayValue)(val))
}

// Set implements the Value interface.
func (val *durationArrayValue) Set(str string) error {
	v, err := time.ParseDuration(str)
	*val = append(*val, v)
	return errs.Wrap(err)
}

// String implements the Value interface.
func (val *durationArrayValue) String() string {
	var str string
	for _, v := range *val {
		if str == "" {
			str += ", "
		}
		str += v.String()
	}
	return str
}
